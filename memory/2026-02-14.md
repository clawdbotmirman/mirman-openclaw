# 2026-02-14 - Initial Setup Day

## Context
First real conversation. User (Daniel Mirman, @clawdbotmirman) is setting me up. Not sure if keeping me or passing to someone else - leaning toward keeping me.

## Major Setup Completed

### Skills Installed
1. **github** - GitHub CLI authenticated as clawdbotmirman
2. **gmail (himalaya)** - Email access working via App Password
3. **goplaces** - Google Places API (needs API key from param store)
4. **nano-pdf** - PDF processing
5. **summarize** - Text/content summarization
6. **habit-tracker** - Habit tracking with streaks
7. **workout-logger** - Workout tracking and PR logging
8. **agent-cost-monitor** - Track AI token usage/costs

### Infrastructure
- AWS Parameter Store setup for secrets:
  - `/openclaw/prod/gmail_app_password`
  - `/openclaw/prod/gmail-oauth-client-id`
  - `/openclaw/prod/gmail-oauth-client-secret`
  - `/openclaw/prod/openai_api_key`
  - `/openclaw/prod/google_places_api_key`
  - Others (Anthropic, GitHub, Telegram tokens)

- **OpenAI backup provider** configured: gpt-4o-mini as fallback
- Rust installed (for himalaya OAuth2 compilation attempt - didn't work, used App Password instead)

### Issues Resolved
- Gmail authentication: 2FA + App Password required (not regular password)
- Himalaya OAuth2: binary not compiled with OAuth2 support, switched to password auth
- GitHub CLI: authenticated via device flow

## TODO for Tomorrow
1. **Identity setup** (BOOTSTRAP.md) - name me, define personality, USER.md
2. **Memory enhancement** - install elite-longterm-memory or similar
3. **Morning stretch habit** - set up daily reminder/tracking
4. **Amazon Business API** - user will set up account, then build ordering skill
5. **Food delivery skills** - browser automation for DoorDash/Instacart (lower priority)

## User Preferences/Context
- Wants accountability for workouts, supplements, morning stretching
- Interested in Amazon/Instacart/DoorDash automation
- Technical user - comfortable with AWS, APIs, Parameter Store
- Going to bed ~6:15am UTC, will resume tomorrow morning

## Skills Flagged (Suspicious, Not Installed)
- cron-scheduling
- morning-routine
- build-discipline

## Memory Skills to Review Tomorrow
- elite-longterm-memory
- memory-hygiene
- memory-manager
- openclaw-mem
- context-engineering
- chromadb-memory

---

## AFTERNOON UPDATE: Hybrid Memory System Installed! ðŸ§ 

**What we built:**
Implemented the full hybrid memory system from Clawdboss.ai's guide:
- **3-tier architecture**: MEMORY.md (always-loaded) + SQLite + FTS5 (structured) + LanceDB (semantic)
- **Auto-capture**: Automatically detects and stores important facts from conversations
- **Auto-recall**: Injects relevant memories into context before each response
- **Memory decay**: 5 tiers (permanent, stable 90d, active 14d, session 24h, checkpoint 4h)
- **Smart classification**: Auto-detects decisions, preferences, facts, entities
- **TTL refresh on access**: Frequently-used facts stay alive, stale ones expire
- **Checkpoints**: Save/restore state before risky operations

**Installation details:**
- Plugin files: `/usr/lib/node_modules/openclaw/extensions/memory-hybrid/`
  - `package.json`, `openclaw.plugin.json`, `config.ts`, `index.ts` (1000+ lines)
- Dependencies: better-sqlite3 (native SQLite), @lancedb/lancedb, openai, @sinclair/typebox
- Database paths:
  - SQLite: `~/.openclaw/memory/facts.db`
  - LanceDB: `~/.openclaw/memory/lancedb`
- Configured in `openclaw.json`:
  - Plugin slot: `plugins.slots.memory = "memory-hybrid"`
  - OpenAI API key from AWS Parameter Store (via cmd retrieval)
  - Auto-capture and auto-recall both enabled

**How it works:**
1. **Storage**: Facts go to SQLite with entity/key/value extraction, embeddings go to LanceDB
2. **Retrieval**: Queries hit both backends, results merge by relevance score (60% BM25 + 25% freshness + 15% confidence)
3. **Decay**: Background hourly prune removes expired facts, decays aging confidence scores
4. **Pattern detection**: Automatically extracts structured fields from natural language:
   - "Decided X because Y" â†’ entity: decision, permanent tier
   - "I prefer X" â†’ entity: user, key: prefer, stable tier
   - "My daughter's birthday is June 3rd" â†’ entity: daughter, key: birthday, permanent

**Tools available:**
- `memory_store(text, importance, category, entity, key, value, decayClass)`
- `memory_recall(query, limit, entity)`
- `memory_forget(query or memoryId)`
- `memory_checkpoint(action: save/restore, intent, state, expectedOutcome, workingFiles)`
- `memory_prune(mode: hard/soft/both)`

**CLI commands:**
- `openclaw hybrid-mem stats` - Statistics with decay breakdown
- `openclaw hybrid-mem search "<query>"` - Search both backends
- `openclaw hybrid-mem lookup <entity> --key <key>` - Exact SQLite lookup
- `openclaw hybrid-mem prune [--dry-run] [--hard] [--soft]` - Clean expired
- `openclaw hybrid-mem checkpoint <save|restore>` - Checkpoint management
- `openclaw hybrid-mem backfill-decay` - Re-classify existing facts

**Test results:**
âœ… Stored preference: "Daniel Mirman prefers to keep credentials in AWS Parameter Store for security"
âœ… Retrieved with semantic query: "Where does Daniel store credentials?" â†’ 100% match
âœ… Stats: 1 SQLite fact, 1 LanceDB vector, classified as "stable" (90-day TTL)

**Cost:** ~$0.0001 per memory stored (embedding generation only, retrieval uses cached embeddings)

**What this solves:**
- No more forgetting context between sessions
- Decisions and rationale persist forever
- Structured facts (names, dates, preferences) retrieved instantly
- Semantic queries work ("what were we discussing about infrastructure?")
- Stale information auto-expires
- Pre-flight checkpoints prevent context loss during long operations

**Next:** Use this system naturally - it will auto-capture important info and recall it when needed!
